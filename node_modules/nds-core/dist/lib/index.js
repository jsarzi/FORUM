/**
 * Nds Core
 * @author Copyright(c) 2021 by Restu wahyu saputra
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "path", "glob", "is-any-type", "js-base64", "../utils/next"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NDSCore = void 0;
    const fs_1 = __importDefault(require("fs"));
    const path_1 = __importDefault(require("path"));
    const glob_1 = __importDefault(require("glob"));
    const is_any_type_1 = require("is-any-type");
    const js_base64_1 = require("js-base64");
    const next_1 = require("../utils/next");
    process.env.TMP_LIN = '/tmp';
    process.env.TMP_WIN = `${process.env.TEMP}/`;
    function mkdir() {
        if (process.platform === 'win32') {
            const isDir = fs_1.default.existsSync(path_1.default.resolve(process.env.TMP_WIN, '.cache'));
            if (!isDir) {
                fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                fs_1.default.mkdirSync(path_1.default.resolve(process.env.TMP_WIN, '.cache'));
                return next_1.next();
            }
            else {
                return next_1.next();
            }
        }
        else {
            const isDir = fs_1.default.existsSync(path_1.default.resolve(process.env.TMP_LIN, '.cache'));
            if (!isDir) {
                fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                fs_1.default.mkdirSync(path_1.default.resolve(process.env.TMP_LIN, '.cache'), { recursive: true });
                return next_1.next();
            }
            else {
                return next_1.next();
            }
        }
    }
    // generate directory before setItem
    mkdir();
    // overwrite environment path default
    process.env.TMP_WIN = process.env.TMP_WIN + '.cache';
    process.env.TMP_LIN = process.env.TMP_LIN + '/.cache';
    class NDSCore {
        set(items) {
            return items.filter((v) => {
                if (process.platform === 'win32') {
                    if (js_base64_1.isValid(v) === false) {
                        const key = js_base64_1.Base64.encodeURI(v.key);
                        const toString = JSON.stringify({ data: v.value });
                        const value = js_base64_1.Base64.encodeURI(toString);
                        fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                        fs_1.default.writeFileSync(path_1.default.resolve(process.env.TMP_WIN, `.${key}.tmp`), `${value}`, {
                            encoding: 'utf-8'
                        });
                        return next_1.next();
                    }
                    else {
                        const key = js_base64_1.Base64.encodeURI(v.key);
                        const toString = JSON.stringify({ data: v.value });
                        const value = js_base64_1.Base64.encodeURI(toString);
                        fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                        fs_1.default.writeFileSync(path_1.default.resolve(process.env.TMP_WIN, `.${this.keys(key)}.tmp`), `${value}`, {
                            encoding: 'utf-8'
                        });
                        return next_1.next();
                    }
                }
                else {
                    if (js_base64_1.isValid(v) === false) {
                        const key = js_base64_1.Base64.encodeURI(v.key);
                        const toString = JSON.stringify({ data: v.value });
                        const value = js_base64_1.Base64.encodeURI(toString);
                        fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                        fs_1.default.writeFileSync(path_1.default.resolve(process.env.TMP_LIN, `.${key}.tmp`), `${value}`, {
                            encoding: 'utf-8'
                        });
                        return next_1.next();
                    }
                    else {
                        const key = js_base64_1.Base64.encodeURI(v.key);
                        const toString = JSON.stringify({ data: v.value });
                        const value = js_base64_1.Base64.encodeURI(toString);
                        fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                        fs_1.default.writeFileSync(path_1.default.resolve(process.env.TMP_LIN, `.${this.keys(key)}.tmp`), `${value}`, {
                            encoding: 'utf-8'
                        });
                        return next_1.next();
                    }
                }
            });
        }
        get(key) {
            if (is_any_type_1.assert.isBoolean(this.exist(key))) {
                if (process.platform === 'win32') {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                    const res = fs_1.default.readFileSync(path_1.default.resolve(process.env.TMP_WIN, `${this.keys(key)}.tmp`), {
                        encoding: 'utf-8'
                    });
                    return JSON.parse(js_base64_1.Base64.decode(res)).data;
                }
                else {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                    const res = fs_1.default.readFileSync(path_1.default.resolve(process.env.TMP_LIN, `${this.keys(key)}.tmp`), {
                        encoding: 'utf-8'
                    });
                    return JSON.parse(js_base64_1.Base64.decode(res)).data;
                }
            }
            else {
                return undefined;
            }
        }
        remove(key) {
            if (is_any_type_1.assert.isBoolean(this.exist(key))) {
                if (process.platform === 'win32') {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                    fs_1.default.unlinkSync(path_1.default.resolve(process.env.TMP_WIN, `${this.keys(key)}.tmp`));
                    return next_1.next();
                }
                else {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                    fs_1.default.unlinkSync(path_1.default.resolve(process.env.TMP_LIN, `${this.keys(key)}.tmp`));
                    return next_1.next();
                }
            }
            else {
                return undefined;
            }
        }
        clear() {
            if (this.match() === true) {
                if (process.platform === 'win32') {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                    glob_1.default
                        .sync(path_1.default.resolve(process.env.TMP_WIN, '.*.tmp'))
                        .map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, ''))
                        .find((v) => fs_1.default.unlinkSync(path_1.default.resolve(process.env.TMP_WIN, `${v}.tmp`)));
                    return next_1.next();
                }
                else {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                    glob_1.default
                        .sync(path_1.default.resolve(process.env.TMP_LIN, '.*.tmp'))
                        .map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, ''))
                        .find((v) => fs_1.default.unlinkSync(path_1.default.resolve(process.env.TMP_LIN, `${v}.tmp`)));
                    return next_1.next();
                }
            }
            else {
                return undefined;
            }
        }
        allKeys() {
            if (this.match() === true) {
                if (process.platform === 'win32') {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                    const res = glob_1.default
                        .sync(path_1.default.resolve(process.env.TMP_WIN, '.*.tmp'))
                        .map((v) => js_base64_1.Base64.decode(v.replace(/^.*[/]|(.tmp)+$/gi, '')));
                    return res !== undefined ? res : undefined;
                }
                else {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                    const res = glob_1.default
                        .sync(path_1.default.resolve(process.env.TMP_LIN, '.*.tmp'), {
                        absolute: true
                    })
                        .map((v) => js_base64_1.Base64.decode(v.replace(/^.*[/]|(.tmp)+$/gi, '')));
                    return res !== undefined ? res : undefined;
                }
            }
            else {
                return undefined;
            }
        }
        exist(key) {
            if (is_any_type_1.assert.isString(this.keys(key))) {
                if (process.platform === 'win32') {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                    return glob_1.default.sync(path_1.default.resolve(process.env.TMP_WIN, `${this.keys(key)}.tmp`)).length > 0 ? true : false;
                }
                else {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                    return glob_1.default.sync(path_1.default.resolve(process.env.TMP_LIN, `${this.keys(key)}.tmp`)).length > 0 ? true : false;
                }
            }
            else {
                return undefined;
            }
        }
        keys(key) {
            if (this.match() === true) {
                if (process.platform === 'win32') {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                    const res = glob_1.default
                        .sync(path_1.default.resolve(process.env.TMP_WIN, '.*.tmp'))
                        .map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, ''))
                        .find((v) => js_base64_1.Base64.decode(v) === key);
                    return res !== undefined ? res : undefined;
                }
                else {
                    fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                    const res = glob_1.default
                        .sync(path_1.default.resolve(process.env.TMP_LIN, '.*.tmp'))
                        .map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, ''))
                        .find((v) => js_base64_1.Base64.decode(v) === key);
                    return res !== undefined ? res : undefined;
                }
            }
            else {
                return undefined;
            }
        }
        match() {
            if (process.platform === 'win32') {
                fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_WIN));
                const isExist = glob_1.default.sync(path_1.default.resolve(process.env.TMP_WIN, '.*.tmp'));
                if (isExist.length > 0)
                    return true;
                else
                    return undefined;
            }
            else {
                fs_1.default.accessSync(path_1.default.resolve(process.env.TMP_LIN));
                const isExist = glob_1.default.sync(path_1.default.resolve(process.env.TMP_LIN, '.*.tmp'));
                if (isExist.length > 0)
                    return true;
                else
                    return undefined;
            }
        }
    }
    exports.NDSCore = NDSCore;
});
